{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 23, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/src/shared/lib/auth0.ts"],"sourcesContent":["import { Auth0Client } from \"@auth0/nextjs-auth0/server\";\n\nexport const auth0 = new Auth0Client({\n  signInReturnToPath: '/api/auth/callback'\n}); "],"names":[],"mappings":";;;AAAA;AAAA;;AAEO,MAAM,QAAQ,IAAI,8KAAA,CAAA,cAAW,CAAC;IACnC,oBAAoB;AACtB"}},
    {"offset": {"line": 38, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/src/shared/lib/auth/jwt.ts"],"sourcesContent":["import { NextRequest } from 'next/server';\n\n// JWT Configuration\nconst JWT_SECRET = process.env.JWT_SECRET || 'your-super-secret-jwt-key-change-in-production';\nconst JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '7d';\nconst JWT_REFRESH_EXPIRES_IN = process.env.JWT_REFRESH_EXPIRES_IN || '30d';\n\nexport interface JWTPayload {\n  userId: number;\n  email: string;\n  auth0UserId?: string;\n  type: 'access' | 'refresh';\n  iat?: number;\n  exp?: number;\n}\n\nexport interface TokenPair {\n  accessToken: string;\n  refreshToken: string;\n  expiresIn: number;\n}\n\n/**\n * JWT Utility Class - Edge Runtime Compatible\n * Uses Web Crypto API instead of Node.js crypto\n */\nexport class JWTUtils {\n  \n  /**\n   * Generate access and refresh token pair\n   */\n  static async generateTokenPair(userId: number, email: string, auth0UserId?: string): Promise<TokenPair> {\n    const now = Math.floor(Date.now() / 1000);\n    const accessExpiry = now + this.getExpirationTime(JWT_EXPIRES_IN);\n    const refreshExpiry = now + this.getExpirationTime(JWT_REFRESH_EXPIRES_IN);\n\n    const accessPayload: JWTPayload = {\n      userId,\n      email,\n      auth0UserId,\n      type: 'access',\n      iat: now,\n      exp: accessExpiry\n    };\n\n    const refreshPayload: JWTPayload = {\n      userId,\n      email,\n      auth0UserId,\n      type: 'refresh',\n      iat: now,\n      exp: refreshExpiry\n    };\n\n    const [accessToken, refreshToken] = await Promise.all([\n      this.signToken(accessPayload),\n      this.signToken(refreshPayload)\n    ]);\n\n    return {\n      accessToken,\n      refreshToken,\n      expiresIn: this.getExpirationTime(JWT_EXPIRES_IN)\n    };\n  }\n\n  /**\n   * Sign JWT token using Web Crypto API\n   */\n  private static async signToken(payload: JWTPayload): Promise<string> {\n    const header = {\n      alg: 'HS256',\n      typ: 'JWT'\n    };\n\n    const encodedHeader = this.base64UrlEncode(JSON.stringify(header));\n    const encodedPayload = this.base64UrlEncode(JSON.stringify(payload));\n    const data = `${encodedHeader}.${encodedPayload}`;\n\n    const signature = await this.hmacSign(data, JWT_SECRET);\n    const encodedSignature = this.base64UrlEncode(signature);\n\n    return `${data}.${encodedSignature}`;\n  }\n\n  /**\n   * Verify and decode JWT token using Web Crypto API\n   */\n  static async verifyToken(token: string): Promise<JWTPayload | null> {\n    try {\n      const parts = token.split('.');\n      if (parts.length !== 3) {\n        return null;\n      }\n\n      const [encodedHeader, encodedPayload, encodedSignature] = parts;\n      const data = `${encodedHeader}.${encodedPayload}`;\n\n      // Verify signature\n      const expectedSignature = await this.hmacSign(data, JWT_SECRET);\n      const expectedEncodedSignature = this.base64UrlEncode(expectedSignature);\n\n      if (encodedSignature !== expectedEncodedSignature) {\n        return null;\n      }\n\n      // Decode payload\n      const payload = JSON.parse(this.base64UrlDecode(encodedPayload)) as JWTPayload;\n\n      // Check expiration\n      if (payload.exp && Date.now() >= payload.exp * 1000) {\n        return null;\n      }\n\n      return payload;\n    } catch (error) {\n      console.error('JWT verification failed:', error);\n      return null;\n    }\n  }\n\n  /**\n   * HMAC sign using Web Crypto API\n   */\n  private static async hmacSign(data: string, secret: string): Promise<string> {\n    const encoder = new TextEncoder();\n    const keyData = encoder.encode(secret);\n    const messageData = encoder.encode(data);\n\n    const key = await crypto.subtle.importKey(\n      'raw',\n      keyData,\n      { name: 'HMAC', hash: 'SHA-256' },\n      false,\n      ['sign']\n    );\n\n    const signature = await crypto.subtle.sign('HMAC', key, messageData);\n    return String.fromCharCode(...new Uint8Array(signature));\n  }\n\n  /**\n   * Base64 URL encode\n   */\n  private static base64UrlEncode(str: string): string {\n    const base64 = btoa(str);\n    return base64.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n  }\n\n  /**\n   * Base64 URL decode\n   */\n  private static base64UrlDecode(str: string): string {\n    // Add padding if needed\n    const padded = str + '==='.slice((str.length + 3) % 4);\n    const base64 = padded.replace(/-/g, '+').replace(/_/g, '/');\n    return atob(base64);\n  }\n\n  /**\n   * Extract token from Authorization header\n   */\n  static extractTokenFromHeader(authHeader: string | null): string | null {\n    if (!authHeader) return null;\n    \n    const parts = authHeader.split(' ');\n    if (parts.length !== 2 || parts[0] !== 'Bearer') {\n      return null;\n    }\n    \n    return parts[1];\n  }\n\n  /**\n   * Extract token from NextRequest\n   */\n  static extractTokenFromRequest(request: NextRequest): string | null {\n    // Try Authorization header first\n    const authHeader = request.headers.get('authorization');\n    const headerToken = this.extractTokenFromHeader(authHeader);\n    if (headerToken) return headerToken;\n\n    // Try cookie as fallback\n    const cookieToken = request.cookies.get('access_token')?.value;\n    if (cookieToken) return cookieToken;\n\n    return null;\n  }\n\n  /**\n   * Validate request and extract user info\n   */\n  static async validateRequest(request: NextRequest): Promise<{\n    isValid: boolean;\n    user?: {\n      userId: number;\n      email: string;\n      auth0UserId?: string;\n    };\n    error?: string;\n  }> {\n    const token = this.extractTokenFromRequest(request);\n    \n    if (!token) {\n      return {\n        isValid: false,\n        error: 'No token provided'\n      };\n    }\n\n    const payload = await this.verifyToken(token);\n    \n    if (!payload) {\n      return {\n        isValid: false,\n        error: 'Invalid token'\n      };\n    }\n\n    if (payload.type !== 'access') {\n      return {\n        isValid: false,\n        error: 'Invalid token type'\n      };\n    }\n\n    return {\n      isValid: true,\n      user: {\n        userId: payload.userId,\n        email: payload.email,\n        auth0UserId: payload.auth0UserId\n      }\n    };\n  }\n\n  /**\n   * Convert time string to seconds\n   */\n  private static getExpirationTime(timeString: string): number {\n    const unit = timeString.slice(-1);\n    const value = parseInt(timeString.slice(0, -1));\n    \n    switch (unit) {\n      case 's': return value;\n      case 'm': return value * 60;\n      case 'h': return value * 60 * 60;\n      case 'd': return value * 60 * 60 * 24;\n      default: return 7 * 24 * 60 * 60; // Default 7 days\n    }\n  }\n\n  /**\n   * Check if token is expired\n   */\n  static isTokenExpired(token: string): boolean {\n    try {\n      const parts = token.split('.');\n      if (parts.length !== 3) return true;\n      \n      const payload = JSON.parse(this.base64UrlDecode(parts[1])) as JWTPayload;\n      if (!payload || !payload.exp) return true;\n      \n      return Date.now() >= payload.exp * 1000;\n    } catch {\n      return true;\n    }\n  }\n\n  /**\n   * Refresh access token using refresh token\n   */\n  static async refreshAccessToken(refreshToken: string): Promise<{\n    success: boolean;\n    accessToken?: string;\n    expiresIn?: number;\n    error?: string;\n  }> {\n    const payload = await this.verifyToken(refreshToken);\n    \n    if (!payload || payload.type !== 'refresh') {\n      return {\n        success: false,\n        error: 'Invalid refresh token'\n      };\n    }\n\n    // Generate new access token\n    const now = Math.floor(Date.now() / 1000);\n    const accessExpiry = now + this.getExpirationTime(JWT_EXPIRES_IN);\n\n    const newAccessPayload: JWTPayload = {\n      userId: payload.userId,\n      email: payload.email,\n      auth0UserId: payload.auth0UserId,\n      type: 'access',\n      iat: now,\n      exp: accessExpiry\n    };\n\n    try {\n      const accessToken = await this.signToken(newAccessPayload);\n      \n      return {\n        success: true,\n        accessToken,\n        expiresIn: this.getExpirationTime(JWT_EXPIRES_IN)\n      };\n    } catch {\n      return {\n        success: false,\n        error: 'Failed to generate new access token'\n      };\n    }\n  }\n} "],"names":[],"mappings":"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"}},
    {"offset": {"line": 276, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/src/shared/lib/auth/auth0-integration.ts"],"sourcesContent":["import { auth0 } from '../auth0';\nimport { NextRequest } from 'next/server';\n\nexport interface Auth0User {\n  sub: string;\n  email: string;\n  name?: string;\n  picture?: string;\n  email_verified?: boolean;\n  [key: string]: any;\n}\n\nexport interface Auth0TokenValidation {\n  isValid: boolean;\n  user?: Auth0User;\n  error?: string;\n}\n\n/**\n * Auth0 Integration Service\n * Handles proper Auth0 token verification and user data extraction\n */\nexport class Auth0Integration {\n  \n  /**\n   * Get Auth0 session from request\n   */\n  static async getAuth0Session(request: NextRequest): Promise<{\n    isAuthenticated: boolean;\n    user?: Auth0User;\n    accessToken?: string;\n    error?: string;\n  }> {\n    try {\n      // Get session using Auth0 SDK\n      const session = await auth0.getSession(request);\n      \n      if (!session || !session.user) {\n        return {\n          isAuthenticated: false,\n          error: 'No Auth0 session found'\n        };\n      }\n\n      // Get access token\n      const accessTokenResult = await auth0.getAccessToken();\n\n      return {\n        isAuthenticated: true,\n        user: session.user as Auth0User,\n        accessToken: accessTokenResult?.token\n      };\n\n    } catch (error) {\n      console.error('❌ Auth0 session error:', error);\n      return {\n        isAuthenticated: false,\n        error: error instanceof Error ? error.message : 'Auth0 session error'\n      };\n    }\n  }\n\n  /**\n   * Validate Auth0 access token\n   */\n  static async validateAuth0Token(token: string): Promise<Auth0TokenValidation> {\n    try {\n      // In a real implementation, you would verify the JWT token\n      // against Auth0's public keys and validate claims\n      \n      // For now, we'll decode the token and validate basic structure\n      const tokenParts = token.split('.');\n      if (tokenParts.length !== 3) {\n        return {\n          isValid: false,\n          error: 'Invalid token format'\n        };\n      }\n\n      // Decode payload\n      const payload = JSON.parse(\n        Buffer.from(tokenParts[1], 'base64').toString('utf-8')\n      );\n\n      // Validate required claims\n      if (!payload.sub || !payload.email) {\n        return {\n          isValid: false,\n          error: 'Missing required claims'\n        };\n      }\n\n      // Check expiration\n      if (payload.exp && Date.now() >= payload.exp * 1000) {\n        return {\n          isValid: false,\n          error: 'Token expired'\n        };\n      }\n\n      // Validate audience and issuer (if configured)\n      const expectedAudience = process.env.AUTH0_AUDIENCE;\n      const expectedIssuer = process.env.AUTH0_ISSUER_BASE_URL;\n\n      if (expectedAudience && payload.aud !== expectedAudience) {\n        return {\n          isValid: false,\n          error: 'Invalid audience'\n        };\n      }\n\n      if (expectedIssuer && payload.iss !== expectedIssuer) {\n        return {\n          isValid: false,\n          error: 'Invalid issuer'\n        };\n      }\n\n      return {\n        isValid: true,\n        user: {\n          sub: payload.sub,\n          email: payload.email,\n          name: payload.name,\n          picture: payload.picture,\n          email_verified: payload.email_verified\n        }\n      };\n\n    } catch (error) {\n      console.error('❌ Token validation error:', error);\n      return {\n        isValid: false,\n        error: error instanceof Error ? error.message : 'Token validation failed'\n      };\n    }\n  }\n\n  /**\n   * Extract user data from Auth0 session\n   */\n  static extractUserData(auth0User: Auth0User): {\n    sub: string;\n    email: string;\n    name?: string;\n    picture?: string;\n  } {\n    return {\n      sub: auth0User.sub,\n      email: auth0User.email,\n      name: auth0User.name || auth0User.nickname || undefined,\n      picture: auth0User.picture || undefined\n    };\n  }\n\n  /**\n   * Check if user email is verified\n   */\n  static isEmailVerified(auth0User: Auth0User): boolean {\n    return auth0User.email_verified === true;\n  }\n\n  /**\n   * Get Auth0 management API token\n   * Used for user management operations\n   */\n  static async getManagementToken(): Promise<string | null> {\n    try {\n      const response = await fetch(`${process.env.AUTH0_ISSUER_BASE_URL}/oauth/token`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          client_id: process.env.AUTH0_CLIENT_ID,\n          client_secret: process.env.AUTH0_CLIENT_SECRET,\n          audience: `${process.env.AUTH0_ISSUER_BASE_URL}/api/v2/`,\n          grant_type: 'client_credentials'\n        })\n      });\n\n      if (!response.ok) {\n        throw new Error('Failed to get management token');\n      }\n\n      const data = await response.json();\n      return data.access_token;\n\n    } catch (error) {\n      console.error('❌ Failed to get Auth0 management token:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Update user metadata in Auth0\n   */\n  static async updateUserMetadata(\n    userId: string, \n    metadata: Record<string, any>\n  ): Promise<boolean> {\n    try {\n      const managementToken = await this.getManagementToken();\n      if (!managementToken) {\n        throw new Error('Failed to get management token');\n      }\n\n      const response = await fetch(\n        `${process.env.AUTH0_ISSUER_BASE_URL}/api/v2/users/${encodeURIComponent(userId)}`,\n        {\n          method: 'PATCH',\n          headers: {\n            'Authorization': `Bearer ${managementToken}`,\n            'Content-Type': 'application/json'\n          },\n          body: JSON.stringify({\n            user_metadata: metadata\n          })\n        }\n      );\n\n      return response.ok;\n\n    } catch (error) {\n      console.error('❌ Failed to update user metadata:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Get user from Auth0 Management API\n   */\n  static async getAuth0User(userId: string): Promise<Auth0User | null> {\n    try {\n      const managementToken = await this.getManagementToken();\n      if (!managementToken) {\n        throw new Error('Failed to get management token');\n      }\n\n      const response = await fetch(\n        `${process.env.AUTH0_ISSUER_BASE_URL}/api/v2/users/${encodeURIComponent(userId)}`,\n        {\n          headers: {\n            'Authorization': `Bearer ${managementToken}`,\n            'Content-Type': 'application/json'\n          }\n        }\n      );\n\n      if (!response.ok) {\n        throw new Error('Failed to get user from Auth0');\n      }\n\n      return await response.json();\n\n    } catch (error) {\n      console.error('❌ Failed to get Auth0 user:', error);\n      return null;\n    }\n  }\n} "],"names":[],"mappings":"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"}},
    {"offset": {"line": 469, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/src/shared/lib/auth/auth-middleware.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport { JWTUtils } from './jwt';\nimport { Auth0Integration } from './auth0-integration';\n\nexport interface AuthContext {\n  isAuthenticated: boolean;\n  authType: 'none' | 'auth0' | 'backend' | 'anonymous';\n  user?: {\n    userId: number;\n    email: string;\n    name?: string;\n    picture?: string;\n    auth0UserId?: string;\n  };\n  sessionToken?: string;\n  error?: string;\n  syncIssue?: {\n    type: 'auth0_missing' | 'backend_missing' | 'both_missing';\n    action: 'clear_backend' | 'redirect_to_auth0' | 'logout_all';\n  };\n}\n\nexport interface MiddlewareConfig {\n  requireAuth?: boolean;\n  allowAnonymous?: boolean;\n  allowAuth0Only?: boolean;\n  allowBackendOnly?: boolean;\n  redirectTo?: string;\n  checkSync?: boolean; // New option to enable synchronization checking\n}\n\n/**\n * Authentication Middleware - Edge Runtime Compatible\n * Enhanced with Auth0/Backend synchronization checking\n */\nexport class AuthMiddleware {\n  \n  /**\n   * Main middleware function with synchronization support\n   */\n  static async authenticate(\n    request: NextRequest,\n    config: MiddlewareConfig = {}\n  ): Promise<{\n    context: AuthContext;\n    response?: NextResponse;\n  }> {\n    const {\n      requireAuth = false,\n      allowAnonymous = true,\n      allowAuth0Only = false,\n      allowBackendOnly = false,\n      redirectTo,\n      checkSync = true\n    } = config;\n\n    // Try different authentication methods in order of preference\n    const authResults = await Promise.allSettled([\n      this.tryBackendAuth(request),\n      this.tryAuth0Auth(request),\n      allowAnonymous ? this.tryAnonymousAuth(request) : Promise.resolve(null)\n    ]);\n\n\n    // Extract results\n    const backendAuth = authResults[0].status === 'fulfilled' ? authResults[0].value : null;\n    const auth0Auth = authResults[1].status === 'fulfilled' ? authResults[1].value : null;\n    const anonymousAuth = authResults[2].status === 'fulfilled' ? authResults[2].value : null;\n\n    // Check for synchronization issues if enabled\n    let syncIssue: AuthContext['syncIssue'] | undefined;\n    if (checkSync && (backendAuth || auth0Auth)) {\n      syncIssue = this.checkAuthSynchronization(backendAuth, auth0Auth);\n    }\n\n    // Handle synchronization issues\n    if (syncIssue) {\n      console.log('⚠️ Auth synchronization issue detected:', syncIssue);\n      \n      if (syncIssue.action === 'clear_backend') {\n        // Clear backend cookies and redirect to login\n        const response = NextResponse.redirect(new URL(redirectTo || '/auth/login', request.url));\n        response.cookies.delete('access_token');\n        response.cookies.delete('refresh_token');\n        \n        return {\n          context: {\n            isAuthenticated: false,\n            authType: 'none',\n            error: 'Authentication cleared due to Auth0 logout',\n            syncIssue\n          },\n          response\n        };\n      } else if (syncIssue.action === 'redirect_to_auth0') {\n        // Redirect to Auth0 callback to sync\n        const response = NextResponse.redirect(new URL('/api/auth/callback', request.url));\n        return {\n          context: {\n            isAuthenticated: false,\n            authType: 'none',\n            error: 'Redirecting to sync authentication',\n            syncIssue\n          },\n          response\n        };\n      } else if (syncIssue.action === 'logout_all') {\n        // Clear everything and redirect to login\n        const response = NextResponse.redirect(new URL(redirectTo || '/auth/login', request.url));\n        response.cookies.delete('access_token');\n        response.cookies.delete('refresh_token');\n        \n        return {\n          context: {\n            isAuthenticated: false,\n            authType: 'none',\n            error: 'Authentication error - logged out',\n            syncIssue\n          },\n          response\n        };\n      }\n    }\n\n    // Find the first successful authentication (prioritize backend, then Auth0, then anonymous)\n    let context: AuthContext = {\n      isAuthenticated: false,\n      authType: 'none'\n    };\n\n    if (backendAuth && !syncIssue) {\n      context = backendAuth;\n    } else if (auth0Auth && !syncIssue) {\n      context = auth0Auth;\n    } else if (anonymousAuth && !syncIssue) {\n      context = anonymousAuth;\n    }\n\n    // Apply restrictions\n    if (allowAuth0Only && context.authType !== 'auth0') {\n      context = {\n        isAuthenticated: false,\n        authType: 'none',\n        error: 'Auth0 authentication required'\n      };\n    }\n\n    if (allowBackendOnly && context.authType !== 'backend') {\n      context = {\n        isAuthenticated: false,\n        authType: 'none',\n        error: 'Backend authentication required'\n      };\n    }\n\n    // Check if authentication is required\n    if (requireAuth && !context.isAuthenticated) {\n      if (redirectTo) {\n        return {\n          context,\n          response: NextResponse.redirect(new URL(redirectTo, request.url))\n        };\n      }\n\n      return {\n        context,\n        response: NextResponse.json(\n          { error: context.error || 'Authentication required' },\n          { status: 401 }\n        )\n      };\n    }\n\n    // Add auth context to request headers\n    const response = NextResponse.next();\n    \n    if (context.isAuthenticated && context.user) {\n      response.headers.set('x-auth-type', context.authType);\n      response.headers.set('x-user-id', context.user.userId.toString());\n      response.headers.set('x-user-email', context.user.email);\n      \n      if (context.sessionToken) {\n        response.headers.set('x-session-token', context.sessionToken);\n      }\n    }\n\n    return { context, response };\n  }\n\n  /**\n   * Check for authentication synchronization issues\n   */\n  private static checkAuthSynchronization(\n    backendAuth: AuthContext | null,\n    auth0Auth: AuthContext | null\n  ): AuthContext['syncIssue'] | undefined {\n    const hasBackend = backendAuth?.isAuthenticated || false;\n    const hasAuth0 = auth0Auth?.isAuthenticated || false;\n\n    console.log('checkAuthSynchronization, hasBackend', hasBackend, 'hasAuth0', hasAuth0)\n\n    // Both authenticated or both not authenticated - in sync\n    if (hasBackend === hasAuth0) {\n      return undefined;\n    }\n\n    // Backend authenticated but Auth0 not - Auth0 session expired/logged out\n    if (hasBackend && !hasAuth0) {\n      return {\n        type: 'auth0_missing',\n        action: 'clear_backend'\n      };\n    }\n\n    // Auth0 authenticated but backend not - need to sync to backend\n    if (!hasBackend && hasAuth0) {\n      return {\n        type: 'backend_missing',\n        action: 'redirect_to_auth0'\n      };\n    }\n\n    // Should not reach here, but handle edge case\n    return {\n      type: 'both_missing',\n      action: 'logout_all'\n    };\n  }\n\n  /**\n   * Try backend JWT authentication - token validation only\n   */\n  private static async tryBackendAuth(request: NextRequest): Promise<AuthContext | null> {\n    try {\n      const validation = await JWTUtils.validateRequest(request);\n      \n      if (!validation.isValid || !validation.user) {\n        return null;\n      }\n\n      // Return user data from JWT token (no database lookup)\n      return {\n        isAuthenticated: true,\n        authType: 'backend',\n        user: {\n          userId: validation.user.userId,\n          email: validation.user.email,\n          auth0UserId: validation.user.auth0UserId\n        }\n      };\n\n    } catch (error) {\n      console.error('❌ Backend auth error:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Try Auth0 authentication - session validation only\n   */\n  private static async tryAuth0Auth(request: NextRequest): Promise<AuthContext | null> {\n    try {\n      const auth0Session = await Auth0Integration.getAuth0Session(request);\n      \n      if (!auth0Session.isAuthenticated || !auth0Session.user) {\n        return null;\n      }\n\n      // Return Auth0 user data (no database lookup)\n      // Note: userId will be 0 as we don't have it from Auth0 session\n      return {\n        isAuthenticated: true,\n        authType: 'auth0',\n        user: {\n          userId: 0, // Placeholder - will be resolved in API routes\n          email: auth0Session.user.email,\n          name: auth0Session.user.name,\n          picture: auth0Session.user.picture,\n          auth0UserId: auth0Session.user.sub\n        }\n      };\n\n    } catch (error) {\n      console.error('❌ Auth0 auth error:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Try anonymous authentication - session token validation only\n   */\n  private static async tryAnonymousAuth(request: NextRequest): Promise<AuthContext | null> {\n    try {\n      // Check for session token in headers or cookies\n      const sessionToken = request.headers.get('x-session-token') || \n                          request.cookies.get('session_token')?.value;\n      \n      if (!sessionToken) {\n        return null;\n      }\n\n      // For edge runtime, we can't validate the session token against database\n      // We'll trust that it exists and let API routes handle validation\n      return {\n        isAuthenticated: true,\n        authType: 'anonymous',\n        sessionToken,\n        user: {\n          userId: 0, // Anonymous user has no userId\n          email: 'anonymous@example.com' // Placeholder\n        }\n      };\n\n    } catch (error) {\n      console.error('❌ Anonymous auth error:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Create middleware for specific routes\n   */\n  static createMiddleware(config: MiddlewareConfig) {\n    return async (request: NextRequest) => {\n      const { context, response } = await this.authenticate(request, config);\n      \n      // If there's a response (redirect or error), return it\n      if (response) {\n        console.log(`🔒 Auth middleware: ${request.nextUrl.pathname} - ${context.isAuthenticated ? 'Authenticated' : 'Not authenticated'}`, {\n          authType: context.authType,\n          hasResponse: !!response,\n          status: response.status,\n          syncIssue: context.syncIssue\n        });\n        return response;\n      }\n\n      // Continue to the page\n      console.log(`✅ Auth middleware: ${request.nextUrl.pathname} - Access granted`, {\n        authType: context.authType,\n        isAuthenticated: context.isAuthenticated\n      });\n      return NextResponse.next();\n    };\n  }\n\n  /**\n   * Middleware for protected routes (requires authentication with sync check)\n   */\n  static protectedRoute = this.createMiddleware({\n    requireAuth: true,\n    redirectTo: '/auth/login',\n    checkSync: true\n  });\n\n  /**\n   * Middleware for API routes (requires authentication, returns JSON)\n   */\n  static protectedAPI = this.createMiddleware({\n    requireAuth: true,\n    checkSync: true\n  });\n\n  /**\n   * Middleware for Auth0-only routes\n   */\n  static auth0Only = this.createMiddleware({\n    requireAuth: true,\n    allowAuth0Only: true,\n    redirectTo: '/auth/login',\n    checkSync: false // Don't check sync for Auth0-only routes\n  });\n\n  /**\n   * Middleware for backend-only routes\n   */\n  static backendOnly = this.createMiddleware({\n    requireAuth: true,\n    allowBackendOnly: true,\n    checkSync: false // Don't check sync for backend-only routes\n  });\n\n  /**\n   * Middleware for anonymous or authenticated routes\n   */\n  static flexible = this.createMiddleware({\n    requireAuth: false,\n    allowAnonymous: true,\n    checkSync: true\n  });\n} "],"names":[],"mappings":"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"}},
    {"offset": {"line": 772, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/src/middleware.ts"],"sourcesContent":["import { NextResponse, type NextRequest } from 'next/server';\nimport { auth0 } from '@/shared/lib/auth0';\nimport { AuthMiddleware } from '@/shared/lib/auth/auth-middleware';\n\nexport async function middleware(request: NextRequest) {\n  const { pathname } = request.nextUrl;\n\n  // Skip middleware for static files and assets\n  if (\n    pathname.startsWith('/_next') ||\n    pathname.startsWith('/favicon') ||\n    pathname.includes('.') ||\n    pathname.startsWith('/api/_')\n  ) {\n    return NextResponse.next();\n  }\n\n  // Handle custom callback route separately\n  if (pathname === '/api/auth/callback') {\n    return NextResponse.next();\n  }\n\n  // Let Auth0 middleware handle Auth0 routes\n  if (pathname.startsWith('/auth')) {\n    return await auth0.middleware(request);\n  }\n\n  // Protected pages that require authentication\n  // Note: These are now also protected by InternalPageTemplate, \n  // but middleware provides additional server-side protection\n  const protectedPages = [\n    '/dashboard',\n    '/profile', \n    '/subscriptions',\n    '/appointments',\n    '/test-auth-protection',\n    '/test-scenarios/protected',\n    '/test-scenarios/dashboard-test'\n  ];\n\n  if (protectedPages.some(page => pathname.startsWith(page))) {\n    return await AuthMiddleware.protectedRoute(request);\n  }\n\n  // Backend-only routes (require backend JWT)\n  const backendOnlyRoutes = [\n    '/api/auth/backend/',\n    '/test-scenarios/backend-only'\n  ];\n\n  if (backendOnlyRoutes.some(route => pathname.startsWith(route))) {\n    return await AuthMiddleware.backendOnly(request);\n  }\n\n  // Auth0-only routes (require Auth0 session)\n  const auth0OnlyRoutes = [\n    '/test-scenarios/auth0-only'\n  ];\n\n  if (auth0OnlyRoutes.some(route => pathname.startsWith(route))) {\n    return await AuthMiddleware.auth0Only(request);\n  }\n\n  // Protected API routes\n  const protectedAPIRoutes = [\n    '/api/patients/my',\n    '/api/subscriptions/my',\n    '/api/payments',\n    '/api/complete-patient-flow',\n    '/api/check-eligibility'\n  ];\n\n  if (protectedAPIRoutes.some(route => pathname.startsWith(route))) {\n    return await AuthMiddleware.protectedAPI(request);\n  }\n\n  // Flexible routes (anonymous or authenticated) - for testing and onboarding\n  const flexibleRoutes = [\n    '/api/progress',\n    '/api/form-data',\n    '/onboarding',\n    '/test-scenarios/flexible',\n    '/test-scenarios/progress-test',\n    '/test-scenarios/anonymous-onboarding',\n    '/test-frontend-auth',\n    '/test-auth-sync'\n  ];\n\n  if (flexibleRoutes.some(route => pathname.startsWith(route))) {\n    return await AuthMiddleware.flexible(request);\n  }\n\n  // Default: pass through\n  return NextResponse.next();\n}\n\nexport const config = {\n  matcher: [\n    /*\n     * Match all request paths except for the ones starting with:\n     * - api (API routes)\n     * - _next/static (static files)\n     * - _next/image (image optimization files)\n     * - favicon.ico (favicon file)\n     */\n    '/((?!_next/static|_next/image|favicon.ico).*)',\n  ],\n} "],"names":[],"mappings":";;;;AAAA;AAAA;AACA;AACA;;;;AAEO,eAAe,WAAW,OAAoB;IACnD,MAAM,EAAE,QAAQ,EAAE,GAAG,QAAQ,OAAO;IAEpC,8CAA8C;IAC9C,IACE,SAAS,UAAU,CAAC,aACpB,SAAS,UAAU,CAAC,eACpB,SAAS,QAAQ,CAAC,QAClB,SAAS,UAAU,CAAC,WACpB;QACA,OAAO,6LAAA,CAAA,eAAY,CAAC,IAAI;IAC1B;IAEA,0CAA0C;IAC1C,IAAI,aAAa,sBAAsB;QACrC,OAAO,6LAAA,CAAA,eAAY,CAAC,IAAI;IAC1B;IAEA,2CAA2C;IAC3C,IAAI,SAAS,UAAU,CAAC,UAAU;QAChC,OAAO,MAAM,qIAAA,CAAA,QAAK,CAAC,UAAU,CAAC;IAChC;IAEA,8CAA8C;IAC9C,+DAA+D;IAC/D,4DAA4D;IAC5D,MAAM,iBAAiB;QACrB;QACA;QACA;QACA;QACA;QACA;QACA;KACD;IAED,IAAI,eAAe,IAAI,CAAC,CAAA,OAAQ,SAAS,UAAU,CAAC,QAAQ;QAC1D,OAAO,MAAM,0JAAA,CAAA,iBAAc,CAAC,cAAc,CAAC;IAC7C;IAEA,4CAA4C;IAC5C,MAAM,oBAAoB;QACxB;QACA;KACD;IAED,IAAI,kBAAkB,IAAI,CAAC,CAAA,QAAS,SAAS,UAAU,CAAC,SAAS;QAC/D,OAAO,MAAM,0JAAA,CAAA,iBAAc,CAAC,WAAW,CAAC;IAC1C;IAEA,4CAA4C;IAC5C,MAAM,kBAAkB;QACtB;KACD;IAED,IAAI,gBAAgB,IAAI,CAAC,CAAA,QAAS,SAAS,UAAU,CAAC,SAAS;QAC7D,OAAO,MAAM,0JAAA,CAAA,iBAAc,CAAC,SAAS,CAAC;IACxC;IAEA,uBAAuB;IACvB,MAAM,qBAAqB;QACzB;QACA;QACA;QACA;QACA;KACD;IAED,IAAI,mBAAmB,IAAI,CAAC,CAAA,QAAS,SAAS,UAAU,CAAC,SAAS;QAChE,OAAO,MAAM,0JAAA,CAAA,iBAAc,CAAC,YAAY,CAAC;IAC3C;IAEA,4EAA4E;IAC5E,MAAM,iBAAiB;QACrB;QACA;QACA;QACA;QACA;QACA;QACA;QACA;KACD;IAED,IAAI,eAAe,IAAI,CAAC,CAAA,QAAS,SAAS,UAAU,CAAC,SAAS;QAC5D,OAAO,MAAM,0JAAA,CAAA,iBAAc,CAAC,QAAQ,CAAC;IACvC;IAEA,wBAAwB;IACxB,OAAO,6LAAA,CAAA,eAAY,CAAC,IAAI;AAC1B;AAEO,MAAM,SAAS;IACpB,SAAS;QACP;;;;;;KAMC,GACD;KACD;AACH"}}]
}